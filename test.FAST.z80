    .engine mycomputer

    .include "constants.asm"
    .include "test.fast.mac.asm"
    
    .include "IOSerial.asm"
    
    ld SP,STACK
    call init
    jp testsStart
    
    .include "Siena.asm"
    .include "ram.asm"

    .org $4000
testsStart:

    ; test ":x 20 let x 100 set x", 100    
    ; test ":x 20 let x 100 set get", 100    
    ; test "#6000 0? 100 set get", 100    

    ; test "[10 20 30] 1?", 20
    ; test ":x [10 20 30] let x 1? 50 set x 1?", 50

    ; test "bytes [1 2 3] 1?", 2
    ; test "bytes :x [1 2 3] let x 1?", 2

    test "bytes [`A` `B` `C`] 1?", 66
    test "bytes [`A` `B` `C`] 1? `Z` set 1?", 90
    

    ; test ":x '' {1} def x", 1

    ; test "1", 1
    ; test "2", 2
    ; test "1", 1
    ; test "0", 0
    ; test "10", 10
    ; test "123", 123
    ; test "-1",-1
    ; test "``", 0
    ; test "`a`", $61
    ; test "`\\``", $60
    ; test "#10", $10
    ; test "#FF", $FF

    ; test "-1 2 +",1
    ; test "-1 1 +",0
    ; test "1 2 +", 3
    ; test "4 1 2 +", 3
    ; test "1 2 +", 3
    ; test "123 456 +", 123+456
    ; test "64 128 +", 64+128
    ; test "-1 -1 -",0
    ; test "5 3 -", 2
    ; test "3 5 &", 1
    ; test "3 5 |", 7
    ; test "2 3 *", 6
    ; test "1 2 3 + *", 5
    ; test "7 3 /", 2
    ; test "7 3 / frac", 1
    ; test "10 sqrt", 3
    ; test "10 sqrt frac", 1

    ; test "2 3 =", FALSE
    ; test "3 3 =", TRUE
    ; test "1 2 <", TRUE
    ; test "2 1 <", FALSE
    ; test "2 3 <", TRUE
    ; test "3 3 <", FALSE
    ; test "1 2 >", FALSE
    ; test "2 1 >", TRUE
    ; test "3 3 >", FALSE
    ; test "4 3 >", TRUE
    ; test "2 2 <=", TRUE
    ; test "2 2 >=", TRUE

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;

    ; test ":x 1000 let x 10 set x", 10
    ; test ":x [100] { @1 } closure x", 100
    ; test ":x [100 200] { @2 } closure x", 200
    ; test ":x [100 200] { @2 $1 + } closure 1 x", 201

    ; test ":x 'a' {$a} def 2 x", 2
    ; test ":x 'a' {$a 3 set $1} def 2 x", 3
    ; test ":x '' { 3 2 } def x + ", 5
    ; test ":x 'a' { $a 2 } def 5 x + ", 7


    ; test "0 [{1}] switch", 1
    ; test "1 [{1} {2} {3}] switch", 2
    ; test "9 [{1} {5}] switch", 5

    ; test ":add1 { $1 0? $2 +} [1] closure 3 add1", 4 

    ; test "bytes 'ABC' get", $41 
    ; test "bytes [1 2 3] get", 1 
    ; test ":xyz 123 const ; xyz", 123
    ; test ":x 1 const ; x", 1 
    ; test ":x 'A' const x get", $41 
    ; test ":x [1] const x get", 1 
    ; test ":x [1 2 3] const x 2?", 3 


    ; test "2 (1 2 +) *", 6
    ; test ":xyz 123 const ; xyz", 123
    ; test ":xyz 123 let ; xyz get", 123
    ; test "1 2 {$1 $2 +} call", 3
    ; test ":xyz {$1 $2 +} def ; 1 2 xyz get", 3

    ; test ":xyz {1} def :xyz addr call", 1
    ; test ":xyz {$1 $2 +} def ; 1 2 :xyz addr call", 3
    ; test ":xyz {10} def :xyz addr exec", 10
    ; test ":xyz {10} def :xyz addr call", 10

    ; test "'hello' hash", $7f54
    ; test ":hello", $7f54

    
    ; test "{{{1} exec} exec} exec", 1
    ; test "5 {{{$1} exec} exec} call", 5

    ; test "5 {$1} call", 5
    ; test "5 {{$1} exec} call", 5

    ; test "2 1 {{$1} call} call", 2
    ; test "2 1 {$2} call", 1
    ; test "2 1 {$1} call", 2
    ; test "2 1 {$2} call", 1
    ; test "2 4 {$2} call", 4
    ; test "{{1} call} call", 1
    ; test "5 {-1 {$1} if} call", 5

    ; test "0 {} loop", 0
    ; test "1 {1-} loop", $1a00

    ; test ":h {1} def :h addr call", 1


    ; ; call enter
    ; ;     .cstr "1 3",$22,"+"
    ; ; expect "1 3 DUP +", 6
    
    call printStr
    .cstr "Done!"
    HALT
    